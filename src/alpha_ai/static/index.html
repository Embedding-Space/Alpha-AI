<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpha AI</title>
    <!-- Markdown and syntax highlighting -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #212121;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #header {
            padding: 12px 16px;
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        #model-select {
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #3a3a3a;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            cursor: pointer;
            min-width: 200px;
        }
        
        #model-select:focus {
            border-color: #4a4a4a;
        }
        
        #model-select option {
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        #new-chat-button {
            background: #0084ff;
            color: white;
            border: none;
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }
        
        #new-chat-button:hover {
            background: #0073e6;
        }
        
        #new-chat-button:disabled {
            background: #4a4a4a;
            cursor: not-allowed;
        }
        
        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .message {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }
        
        .message.user {
            align-self: flex-end;
            background: #0084ff;
            color: white;
            border-bottom-right-radius: 4px;
        }
        
        .message.assistant {
            align-self: flex-start;
            background: #383838;
            color: #e0e0e0;
            border-bottom-left-radius: 4px;
        }
        
        /* Markdown content styling */
        .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 {
            margin: 0.5em 0;
        }
        
        .message h1 { font-size: 1.5em; }
        .message h2 { font-size: 1.3em; }
        .message h3 { font-size: 1.1em; }
        
        .message p {
            margin: 0 0 0.5em 0;
        }
        
        /* Remove margin between consecutive paragraphs */
        .message p + p {
            margin-top: 0.5em;
        }
        
        /* Remove top margin from first element */
        .message > *:first-child {
            margin-top: 0;
        }
        
        /* Remove bottom margin from last element */
        .message > *:last-child {
            margin-bottom: 0;
        }
        
        .message code {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 0.9em;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .message pre {
            background: #1a1a1a;
            padding: 1em;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5em 0;
        }
        
        .message pre code {
            background: none;
            padding: 0;
            font-size: 0.9em;
        }
        
        .message ul, .message ol {
            margin: 0.5em 0;
            padding-left: 1.5em;
        }
        
        .message li {
            margin: 0.25em 0;
        }
        
        .message blockquote {
            border-left: 3px solid #4a4a4a;
            padding-left: 1em;
            margin: 0.5em 0;
            color: #aaa;
        }
        
        .message a {
            color: #58a6ff;
            text-decoration: none;
        }
        
        .message a:hover {
            text-decoration: underline;
        }
        
        .message table {
            border-collapse: collapse;
            margin: 0.5em 0;
        }
        
        .message th, .message td {
            border: 1px solid #4a4a4a;
            padding: 0.5em;
        }
        
        .message th {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .message.system {
            align-self: center;
            background: transparent;
            color: #888;
            font-size: 14px;
            text-align: center;
            padding: 8px 16px;
        }
        
        /* Tool call styles */
        .tool-calls {
            max-width: 70%;
            align-self: flex-start;
            margin: 8px 0;
        }
        
        .tool-call {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            margin-bottom: 8px;
            overflow: hidden;
        }
        
        .tool-call-header {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            font-size: 14px;
            color: #aaa;
        }
        
        .tool-call-header:hover {
            background: #333;
        }
        
        .tool-call-arrow {
            font-size: 12px;
            transition: transform 0.2s;
        }
        
        .tool-call-arrow.expanded {
            transform: rotate(90deg);
        }
        
        .tool-call-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .tool-call-content.expanded {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .tool-call-section {
            padding: 12px;
            border-top: 1px solid #3a3a3a;
        }
        
        .tool-call-section h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            font-weight: normal;
        }
        
        .tool-call-json {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            overflow-x: auto;
            color: #e0e0e0;
        }
        
        /* JSON syntax highlighting */
        .tool-call-json .json-key {
            color: #7ec699;
        }
        
        .tool-call-json .json-string {
            color: #e6c07b;
        }
        
        .tool-call-json .json-number {
            color: #d19a66;
        }
        
        .tool-call-json .json-boolean {
            color: #56b6c2;
        }
        
        .tool-call-json .json-null {
            color: #abb2bf;
        }
        
        #input-container {
            padding: 16px;
            background: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        
        #input {
            flex: 1;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 12px 16px;
            border-radius: 24px;
            font-size: 16px;
            resize: none;
            outline: none;
            min-height: 24px;
            max-height: 120px;
            line-height: 24px;
            font-family: inherit;
        }
        
        #input:focus {
            border-color: #4a4a4a;
        }
        
        #input::placeholder {
            color: #666;
        }
        
        #input:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        #send-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: #0084ff;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        #send-button:hover:not(:disabled) {
            background: #0073e6;
            transform: scale(1.05);
        }
        
        #send-button:disabled {
            background: #4a4a4a;
            cursor: not-allowed;
        }
        
        #send-button.stop {
            background: #ff3b30;
        }
        
        #send-button.stop:hover {
            background: #e60000;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }
        
        /* Typing indicator */
        .typing-indicator {
            align-self: flex-start;
            padding: 12px 16px;
            background: #383838;
            border-radius: 18px;
            border-bottom-left-radius: 4px;
            display: flex;
            gap: 4px;
            align-items: center;
        }
        
        .typing-indicator span {
            width: 8px;
            height: 8px;
            background: #666;
            border-radius: 50%;
            animation: pulse 1.4s infinite;
        }
        
        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes pulse {
            0%, 60%, 100% {
                opacity: 0.3;
                transform: scale(0.8);
            }
            30% {
                opacity: 1;
                transform: scale(1);
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <span style="font-weight: 600; font-size: 16px;">Alpha AI</span>
        <span style="color: #888; font-size: 14px;">Model:</span>
        <select id="model-select">
            <option value="">Loading models...</option>
        </select>
        <button id="new-chat-button">New Chat</button>
        <label style="margin-left: auto; display: flex; align-items: center; gap: 8px; color: #e0e0e0; font-size: 14px;">
            <input type="checkbox" id="streaming-toggle" checked>
            Streaming
        </label>
    </div>
    
    <div id="messages"></div>
    
    <div id="input-container">
        <textarea id="input" placeholder="Message Alpha..." rows="1"></textarea>
        <button id="send-button" title="Send message">↑</button>
    </div>
    
    <script>
        const API_BASE = '/api/v1';
        const messagesDiv = document.getElementById('messages');
        const input = document.getElementById('input');
        const modelSelect = document.getElementById('model-select');
        const newChatButton = document.getElementById('new-chat-button');
        const streamingToggle = document.getElementById('streaming-toggle');
        const sendButton = document.getElementById('send-button');
        let typingIndicator = null;
        let useStreaming = true; // Default to streaming mode
        let currentReader = null; // Track current stream reader for aborting
        
        // Configure marked for GitHub-flavored Markdown
        marked.setOptions({
            gfm: true,
            breaks: false,  // Don't convert single line breaks to <br>
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (err) {
                        console.error('Highlight error:', err);
                    }
                }
                return hljs.highlightAuto(code).value;
            }
        });
        
        // Render markdown to HTML
        function renderMarkdown(text) {
            // Normalize excessive newlines while preserving intentional paragraph breaks
            const normalized = text
                .replace(/\n\s*\n\s*\n+/g, '\n\n')  // Replace 3+ newlines with exactly 2
                .replace(/\n\n+/g, '\n\n')           // Ensure max 2 consecutive newlines
                .trim();                             // Remove leading/trailing whitespace
            
            // Parse markdown
            const html = marked.parse(normalized);
            
            // Remove trailing empty paragraphs
            return html.replace(/<p>\s*<\/p>\s*$/g, '').trim();
        }
        
        // Syntax highlight JSON
        function highlightJSON(json) {
            // Format JSON with proper indentation
            const formatted = JSON.stringify(json, null, 2);
            
            // Apply syntax highlighting
            return formatted
                .replace(/("(\\u[a-fA-F0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?)/g, function (match, p1, p2, p3) {
                    const cls = p3 ? 'json-key' : 'json-string';
                    return '<span class="' + cls + '">' + match + '</span>';
                })
                .replace(/\b(true|false)\b/g, '<span class="json-boolean">$1</span>')
                .replace(/\bnull\b/g, '<span class="json-null">null</span>')
                .replace(/\b(-?\d+(\.\d+)?([eE][+-]?\d+)?)\b/g, '<span class="json-number">$1</span>');
        }
        
        // Handle streaming toggle
        streamingToggle.addEventListener('change', (e) => {
            useStreaming = e.target.checked;
        });
        
        // Auto-resize textarea
        input.addEventListener('input', () => {
            input.style.height = 'auto';
            input.style.height = input.scrollHeight + 'px';
        });
        
        // Handle enter/shift+enter
        input.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!sendButton.disabled && !sendButton.classList.contains('stop')) {
                    await sendMessage();
                }
            }
        });
        
        // Handle send/stop button
        sendButton.addEventListener('click', async () => {
            if (sendButton.classList.contains('stop')) {
                stopGeneration();
            } else {
                await sendMessage();
            }
        });
        
        // Load available models
        async function loadModels() {
            try {
                const response = await fetch(`${API_BASE}/models`);
                const data = await response.json();
                
                // Clear existing options
                modelSelect.innerHTML = '';
                
                // Group models by provider
                const modelsByProvider = {};
                data.models.forEach(model => {
                    if (!modelsByProvider[model.provider]) {
                        modelsByProvider[model.provider] = [];
                    }
                    modelsByProvider[model.provider].push(model);
                });
                
                // Add options grouped by provider
                Object.keys(modelsByProvider).sort().forEach(provider => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = provider;
                    
                    modelsByProvider[provider].forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.name;
                        if (model.id === data.current) {
                            option.selected = true;
                        }
                        optgroup.appendChild(option);
                    });
                    
                    modelSelect.appendChild(optgroup);
                });
            } catch (error) {
                console.error('Error loading models:', error);
                modelSelect.innerHTML = '<option value="">Error loading models</option>';
            }
        }
        
        // Handle new chat button
        newChatButton.addEventListener('click', async () => {
            const selectedModel = modelSelect.value;
            if (!selectedModel) {
                alert('Please select a model first');
                return;
            }
            
            if (!confirm(`Start a new chat with ${modelSelect.options[modelSelect.selectedIndex].text}? This will clear the current conversation.`)) {
                return;
            }
            
            try {
                newChatButton.disabled = true;
                const response = await fetch(`${API_BASE}/conversation/new`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: selectedModel })
                });
                
                if (response.ok) {
                    // Clear the messages
                    messagesDiv.innerHTML = '';
                    input.focus();
                } else {
                    const error = await response.json();
                    alert(`Error: ${error.detail || 'Failed to start new conversation'}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            } finally {
                newChatButton.disabled = false;
            }
        });
        
        
        // Add message to UI
        function addMessage(role, content, toolCalls = null) {
            // Remove typing indicator if present
            if (typingIndicator) {
                typingIndicator.remove();
                typingIndicator = null;
            }
            
            // Add tool calls BEFORE the assistant message if this is an assistant message with tools
            if (role === 'assistant' && toolCalls && toolCalls.length > 0) {
                const toolCallsDiv = document.createElement('div');
                toolCallsDiv.className = 'tool-calls';
                
                toolCalls.forEach((toolCallPair, index) => {
                    const [call, result] = toolCallPair;
                    const toolDiv = createToolCallElement(call, result, index);
                    toolCallsDiv.appendChild(toolDiv);
                });
                
                messagesDiv.appendChild(toolCallsDiv);
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            // Render markdown for assistant messages, plain text for others
            if (role === 'assistant') {
                messageDiv.innerHTML = renderMarkdown(content);
            } else {
                messageDiv.textContent = content;
            }
            
            messagesDiv.appendChild(messageDiv);
            
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        // Create collapsible tool call element
        function createToolCallElement(call, result, index) {
            const toolDiv = document.createElement('div');
            toolDiv.className = 'tool-call';
            
            // Header
            const header = document.createElement('div');
            header.className = 'tool-call-header';
            header.innerHTML = `
                <span class="tool-call-arrow">▶</span>
                <span>${call.tool_name}</span>
            `;
            
            // Content
            const content = document.createElement('div');
            content.className = 'tool-call-content';
            const responseContent = result ? highlightJSON({ content: result.content }) : 'Waiting for response...';
            content.innerHTML = `
                <div class="tool-call-section">
                    <h4>Request</h4>
                    <div class="tool-call-json">${highlightJSON({ tool_name: call.tool_name, args: call.args })}</div>
                </div>
                <div class="tool-call-section">
                    <h4>Response</h4>
                    <div class="tool-call-json">${responseContent}</div>
                </div>
            `;
            
            // Toggle functionality
            header.addEventListener('click', () => {
                const arrow = header.querySelector('.tool-call-arrow');
                arrow.classList.toggle('expanded');
                content.classList.toggle('expanded');
            });
            
            toolDiv.appendChild(header);
            toolDiv.appendChild(content);
            
            return toolDiv;
        }
        
        // Show typing indicator
        function showTypingIndicator() {
            if (typingIndicator) return;
            
            typingIndicator = document.createElement('div');
            typingIndicator.className = 'typing-indicator';
            typingIndicator.innerHTML = '<span></span><span></span><span></span>';
            messagesDiv.appendChild(typingIndicator);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        // Stop generation
        function stopGeneration() {
            if (currentReader) {
                currentReader.cancel();
                currentReader = null;
            }
            
            // Reset button state
            sendButton.classList.remove('stop');
            sendButton.innerHTML = '↑';
            sendButton.title = 'Send message';
            sendButton.disabled = false;
            
            // Remove typing indicator
            if (typingIndicator) {
                typingIndicator.remove();
                typingIndicator = null;
            }
            
            // Add system message
            addMessage('system', 'Generation stopped by user');
        }
        
        // Send message with streaming support
        async function sendMessage() {
            const message = input.value.trim();
            if (!message) return;
            
            // Disable input and update button
            input.disabled = true;
            sendButton.disabled = true;
            
            // Clear and reset input
            input.value = '';
            input.style.height = 'auto';
            
            // Add user message
            addMessage('user', message);
            
            // Show typing indicator
            showTypingIndicator();
            
            if (useStreaming) {
                await sendMessageStreaming(message);
            } else {
                await sendMessageNonStreaming(message);
            }
            
            // Re-enable input
            input.disabled = false;
            input.focus();
        }
        
        // Non-streaming message send (original method)
        async function sendMessageNonStreaming(message) {
            try {
                const response = await fetch(`${API_BASE}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    addMessage('assistant', data.response, data.tool_calls);
                    // Update model if changed
                    // Model is fixed at startup, no need to update
                } else {
                    addMessage('system', `Error: ${data.detail || 'Unknown error'}`);
                }
            } catch (error) {
                addMessage('system', `Error: ${error.message}`);
            } finally {
                // Reset button state
                sendButton.disabled = false;
                sendButton.innerHTML = '↑';
                sendButton.title = 'Send message';
            }
        }
        
        // Streaming message send using SSE
        async function sendMessageStreaming(message) {
            try {
                // Update button to stop mode
                sendButton.classList.add('stop');
                sendButton.innerHTML = '⏹';
                sendButton.title = 'Stop generation';
                sendButton.disabled = false;
                
                const response = await fetch(`${API_BASE}/chat/stream`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    addMessage('system', `Error: ${error.detail || 'Unknown error'}`);
                    return;
                }
                
                // Remove typing indicator
                if (typingIndicator) {
                    typingIndicator.remove();
                    typingIndicator = null;
                }
                
                // We'll create the message div when we actually get text
                let currentMessageDiv = null;
                
                // Track the raw text for markdown rendering
                let currentMessageText = '';
                
                // Track tool calls and their container
                let pendingToolCalls = new Map();
                let currentToolCallsContainer = null;
                
                // Read the stream
                const reader = response.body.getReader();
                currentReader = reader; // Track for cancellation
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                if (data.type === 'start') {
                                    // Update model if changed
                                    // Model is fixed at startup, no need to update
                                } else if (data.type === 'text_delta') {
                                    // If we need a new message div (e.g., after tool calls), create one
                                    if (!currentMessageDiv || !currentMessageDiv.parentNode) {
                                        currentMessageDiv = document.createElement('div');
                                        currentMessageDiv.className = 'message assistant';
                                        currentMessageDiv.innerHTML = '';
                                        messagesDiv.appendChild(currentMessageDiv);
                                        currentMessageText = ''; // Reset text accumulator
                                    }
                                    // Accumulate text and re-render markdown
                                    currentMessageText += data.content;
                                    currentMessageDiv.innerHTML = renderMarkdown(currentMessageText);
                                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                                } else if (data.type === 'tool_call') {
                                    // Create tool calls container if it doesn't exist
                                    if (!currentToolCallsContainer) {
                                        currentToolCallsContainer = document.createElement('div');
                                        currentToolCallsContainer.className = 'tool-calls';
                                        // Don't append yet - we'll do it after the current message
                                    }
                                    
                                    const toolCallDiv = createToolCallElement(
                                        { tool_name: data.tool_name, args: data.args, tool_call_id: data.tool_call_id },
                                        null,  // No result yet
                                        pendingToolCalls.size
                                    );
                                    currentToolCallsContainer.appendChild(toolCallDiv);
                                    pendingToolCalls.set(data.tool_call_id, toolCallDiv);
                                } else if (data.type === 'tool_return') {
                                    // Update tool call with result
                                    const toolCallDiv = pendingToolCalls.get(data.tool_call_id);
                                    if (toolCallDiv) {
                                        // Update the existing tool call div with the result
                                        const contentDiv = toolCallDiv.querySelector('.tool-call-content');
                                        const responseSection = contentDiv.querySelector('.tool-call-section:last-child .tool-call-json');
                                        responseSection.innerHTML = highlightJSON({ content: data.content });
                                    }
                                    
                                    // Now append the tool calls container after the message (if we haven't already)
                                    if (currentToolCallsContainer && !currentToolCallsContainer.parentNode) {
                                        messagesDiv.appendChild(currentToolCallsContainer);
                                    }
                                    
                                    // Reset tool calls container for next batch
                                    currentToolCallsContainer = null;
                                    
                                    // Reset current message div so next text creates a new bubble
                                    currentMessageDiv = null;
                                    currentMessageText = ''; // Reset text accumulator for new message
                                } else if (data.type === 'done') {
                                    // Ensure tool calls are appended if we have any
                                    if (currentToolCallsContainer && !currentToolCallsContainer.parentNode) {
                                        messagesDiv.appendChild(currentToolCallsContainer);
                                    }
                                    
                                    // Clean up empty message divs if they exist
                                    if (currentMessageDiv && !currentMessageText.trim()) {
                                        currentMessageDiv.remove();
                                    }
                                    
                                    // Reset button state when done
                                    currentReader = null;
                                    sendButton.classList.remove('stop');
                                    sendButton.innerHTML = '↑';
                                    sendButton.title = 'Send message';
                                    sendButton.disabled = false;
                                } else if (data.type === 'error') {
                                    addMessage('system', `Error: ${data.error}`);
                                }
                            } catch (e) {
                                console.error('Failed to parse SSE data:', e);
                            }
                        }
                    }
                }
                
                // Final cleanup: remove any empty message divs after streaming ends
                if (currentMessageDiv && !currentMessageText.trim()) {
                    currentMessageDiv.remove();
                }
            } catch (error) {
                // Handle cancellation gracefully
                if (error.name !== 'AbortError') {
                    addMessage('system', `Error: ${error.message}`);
                }
            } finally {
                // Reset button state
                currentReader = null;
                sendButton.classList.remove('stop');
                sendButton.innerHTML = '↑';
                sendButton.title = 'Send message';
                sendButton.disabled = false;
            }
        }
        
        // Load conversation history
        async function loadHistory() {
            try {
                const response = await fetch(`${API_BASE}/conversation`);
                const data = await response.json();
                
                // Add existing messages with tool calls
                data.messages.forEach(msg => {
                    addMessage(msg.role, msg.content, msg.tool_calls);
                });
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }
        
        // Initialize
        loadModels();
        loadHistory();
        input.focus();
    </script>
</body>
</html>